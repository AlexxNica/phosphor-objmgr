#!/usr/bin/env python

# Contributors Listed Below - COPYRIGHT 2016
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

import dbus
import dbus.service
import dbus.exceptions
import dbus.mainloop.glib
import gobject
from obmc.dbuslib.introspection import IntrospectionParser
import obmc.utils.pathtree
import obmc.utils.misc
import obmc.mapper
import obmc.dbuslib.bindings


class MapperNotFoundException(dbus.exceptions.DBusException):
    _dbus_error_name = obmc.mapper.MAPPER_NOT_FOUND

    def __init__(self, path):
        super(MapperNotFoundException, self).__init__(
            "path or object not found: %s" % (path))


class ObjectMapper(dbus.service.Object):
    def __init__(self, bus, path,
                 name_match=obmc.utils.misc.org_dot_openbmc_match,
                 intf_match=obmc.utils.misc.org_dot_openbmc_match):
        super(ObjectMapper, self).__init__(bus.dbus, path)
        self.cache = obmc.utils.pathtree.PathTree()
        self.bus = bus
        self.name_match = name_match
        self.intf_match = intf_match
        self.tag_match = obmc.utils.misc.ListMatch(['children', 'interface'])
        self.service = None

        gobject.idle_add(self.discover)
        self.bus.dbus.add_signal_receiver(
            self.bus_handler,
            dbus_interface=
            dbus.BUS_DAEMON_IFACE,
            signal_name='NameOwnerChanged')
        self.bus.dbus.add_signal_receiver(
            self.interfaces_added_handler,
            dbus_interface=
            dbus.BUS_DAEMON_IFACE + '.ObjectManager',
            signal_name='InterfacesAdded',
            sender_keyword='sender')
        self.bus.dbus.add_signal_receiver(
            self.interfaces_removed_handler,
            dbus_interface=dbus.BUS_DAEMON_IFACE + '.ObjectManager',
            signal_name='InterfacesRemoved',
            sender_keyword='sender')

    def bus_match(self, name):
        if name == obmc.mapper.MAPPER_NAME:
            return False
        return self.name_match(name)

    def discovery_pending(self):
        return not bool(self.service)

    def interfaces_added_handler(self, path, iprops, **kw):
        path = str(path)
        owner = str(kw['sender'])
        interfaces = self.get_signal_interfaces(owner, iprops.iterkeys())
        cache_entry = self.cache.get(path, {})
        old = self.interfaces_get(cache_entry, owner)
        new = list(set(interfaces).union(old))
        self.update_interfaces(path, owner, old, new)

    def interfaces_removed_handler(self, path, interfaces, **kw):
        path = str(path)
        owner = str(kw['sender'])
        interfaces = self.get_signal_interfaces(owner, interfaces)
        cache_entry = self.cache.get(path, {})
        old = self.interfaces_get(cache_entry, owner)
        new = list(set(old).difference(interfaces))
        self.update_interfaces(path, owner, old, new)

    def process_new_owner(self, name):
        # unique name
        return self.discover([IntrospectionParser(name,
                             self.bus.dbus,
                             self.tag_match,
                             self.intf_match)])

    def process_old_owner(self, name):
        for path, item in self.cache.dataitems():
            old = self.interfaces_get(item, name)
            # remove all interfaces for this service
            self.update_interfaces(
                path, name, old=old, new=[])

    def bus_handler(self, owner, old, new):
        valid = False
        if not obmc.dbuslib.bindings.is_unique(owner):
            valid = self.valid_signal(owner)

        if valid and new:
            self.process_new_owner(new)
        if valid and old:
            self.process_old_owner(old)

    def update_interfaces(self, path, owner, old, new):
        cache_entry = self.cache.setdefault(path, {})
        added = list(set(new).difference(old))
        removed = list(set(old).difference(new))
        self.interfaces_append(cache_entry, owner, added)
        self.interfaces_remove(cache_entry, owner, removed, path)

    def add_items(self, owner, bus_items):
        for path, items in bus_items.iteritems():
            # convert dbus types to native.
            interfaces = [str(i) for i in items.get('interfaces', [])]
            self.update_interfaces(path, str(owner), old=[], new=interfaces)

    def discover(self, owners=None):
        if not owners:
            owners = [IntrospectionParser(x, self.bus.dbus,
                                          self.tag_match,
                                          self.intf_match)
                      for x in self.bus.get_owner_names(self.bus_match)]
        for o in owners:
            self.add_items(o.name, o.introspect())

        if self.discovery_pending():
            print "ObjectMapper discovery complete..."
            self.service = dbus.service.BusName(
                obmc.mapper.MAPPER_NAME, self.bus.dbus)

    def valid_signal(self, owner):
        if obmc.dbuslib.bindings.is_unique(owner):
            owner = self.bus.get_owned_name(self.bus_match, owner)

        return owner is not None and not self.discovery_pending() and \
            self.bus_match(owner)

    def get_signal_interfaces(self, owner, interfaces):
        filtered = []
        if self.valid_signal(owner):
            filtered = [str(x) for x in interfaces if self.intf_match(x)]

        return filtered

    @staticmethod
    def interfaces_get(item, owner, default=[]):
        return item.get(owner, default)

    @staticmethod
    def interfaces_append(item, owner, append):
        interfaces = item.setdefault(owner, [])
        item[owner] = list(set(append).union(interfaces))

    def interfaces_remove(self, item, owner, remove, path):
        interfaces = item.get(owner, [])
        item[owner] = list(set(interfaces).difference(remove))

        if not item[owner]:
            # remove the owner if there aren't any interfaces left
            del item[owner]

        if item:
            # other owners remain
            return

        if self.cache.get_children(path):
            # there are still references to this path
            # from objects further down the tree.
            # mark it for removal if that changes
            self.cache.demote(path)
        else:
            # delete the entire path if everything is gone
            del self.cache[path]

    @dbus.service.method(obmc.mapper.MAPPER_IFACE, 's', 'a{sas}')
    def GetObject(self, path):
        o = self.cache.get(path)
        if not o:
            raise MapperNotFoundException(path)
        return o

    @dbus.service.method(obmc.mapper.MAPPER_IFACE, 'si', 'as')
    def GetSubTreePaths(self, path, depth):
        try:
            return self.cache.iterkeys(path, depth)
        except KeyError:
            raise MapperNotFoundException(path)

    @dbus.service.method(obmc.mapper.MAPPER_IFACE, 'si', 'a{sa{sas}}')
    def GetSubTree(self, path, depth):
        try:
            return {x: y for x, y in self.cache.dataitems(path, depth)}
        except KeyError:
            raise MapperNotFoundException(path)


class BusWrapper:
    def __init__(self, bus):
        self.dbus = bus

    def get_owned_name(self, match, bus):
        for x in self.get_service_names(match):
            if self.dbus.get_name_owner(x) == bus:
                return x

    def get_service_names(self, match):
        # these are well known names
        return [x for x in self.dbus.list_names()
                if match(x)]

    def get_owner_names(self, match):
        # these are unique connection names
        return list(set(
            [self.dbus.get_name_owner(x)
                for x in self.get_service_names(match)]))

if __name__ == '__main__':
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
    bus = dbus.SystemBus()
    o = ObjectMapper(BusWrapper(bus), obmc.mapper.MAPPER_PATH)
    loop = gobject.MainLoop()

    loop.run()
